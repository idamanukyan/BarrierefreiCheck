name: Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      strategy:
        description: 'Deployment strategy'
        required: true
        default: 'blue-green'
        type: choice
        options:
          - blue-green
          - rolling

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository }}

jobs:
  # Build all images
  build:
    name: Build Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      version: ${{ steps.version.outputs.version }}
    strategy:
      matrix:
        component: [api, frontend, scanner]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get version
        id: version
        run: |
          VERSION=$(git describe --tags --always --dirty)
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.component }}
          file: ./${{ matrix.component }}/Dockerfile.prod
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${{ matrix.component }}:${{ steps.version.outputs.version }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${{ matrix.component }}:${{ inputs.environment }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ steps.version.outputs.version }}

  # Run tests against built images
  test:
    name: Test Images
    runs-on: ubuntu-latest
    needs: build

    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_DB: test_db
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull and test API image
        run: |
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-api:${{ needs.build.outputs.version }}

          # Run health check
          docker run -d --name api-test \
            --network host \
            -e DATABASE_URL=postgresql://test_user:test_password@localhost:5432/test_db \
            -e REDIS_URL=redis://localhost:6379 \
            -e JWT_SECRET=test-secret-key-that-is-at-least-32-characters-long \
            -e APP_ENV=test \
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-api:${{ needs.build.outputs.version }}

          # Wait for API to be ready
          sleep 10
          curl -f http://localhost:8000/api/v1/health || exit 1

          docker stop api-test

  # Deploy to staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build, test]
    if: inputs.environment == 'staging'
    environment:
      name: staging
      url: https://staging.barrierefrei-check.de

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to staging server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          script: |
            cd /opt/accessibilitychecker

            # Pull latest images
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-api:${{ needs.build.outputs.version }}
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-frontend:${{ needs.build.outputs.version }}
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-scanner:${{ needs.build.outputs.version }}

            # Update docker-compose with new version
            export APP_VERSION=${{ needs.build.outputs.version }}

            # Rolling restart
            docker compose -f docker-compose.prod.yml up -d --no-deps api
            sleep 10
            docker compose -f docker-compose.prod.yml up -d --no-deps frontend scanner

            # Verify health
            curl -f http://localhost:8000/api/v1/health

      - name: Notify deployment
        if: success()
        run: |
          echo "Staging deployment successful: ${{ needs.build.outputs.version }}"

  # Deploy to production with blue-green strategy
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build, test]
    if: inputs.environment == 'production'
    environment:
      name: production
      url: https://barrierefrei-check.de

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Blue-Green Deployment
        if: inputs.strategy == 'blue-green'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          script: |
            cd /opt/accessibilitychecker

            # Determine current color
            CURRENT_COLOR=$(cat .current-color 2>/dev/null || echo "blue")
            if [ "$CURRENT_COLOR" = "blue" ]; then
              NEW_COLOR="green"
            else
              NEW_COLOR="blue"
            fi

            echo "Current: $CURRENT_COLOR, Deploying to: $NEW_COLOR"

            # Pull new images
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-api:${{ needs.build.outputs.version }}
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-frontend:${{ needs.build.outputs.version }}
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-scanner:${{ needs.build.outputs.version }}

            # Start new version on different ports
            export APP_VERSION=${{ needs.build.outputs.version }}
            export DEPLOY_COLOR=$NEW_COLOR

            # Start new containers
            docker compose -f docker-compose.$NEW_COLOR.yml up -d

            # Wait for new version to be healthy
            echo "Waiting for new version to be healthy..."
            for i in {1..30}; do
              if curl -sf http://localhost:800${NEW_COLOR:0:1}/api/v1/health; then
                echo "New version is healthy!"
                break
              fi
              sleep 2
            done

            # Switch traffic (update nginx/load balancer config)
            if [ -f /etc/nginx/conf.d/accessibilitychecker.conf ]; then
              sed -i "s/800[01]/800${NEW_COLOR:0:1}/" /etc/nginx/conf.d/accessibilitychecker.conf
              nginx -t && nginx -s reload
            fi

            # Save current color
            echo $NEW_COLOR > .current-color

            # Keep old version running for 5 minutes for rollback
            echo "Keeping old version for potential rollback..."
            sleep 300

            # Stop old version
            docker compose -f docker-compose.$CURRENT_COLOR.yml down

      - name: Rolling Deployment
        if: inputs.strategy == 'rolling'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          script: |
            cd /opt/accessibilitychecker

            # Pull new images
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-api:${{ needs.build.outputs.version }}
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-frontend:${{ needs.build.outputs.version }}
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-scanner:${{ needs.build.outputs.version }}

            export APP_VERSION=${{ needs.build.outputs.version }}

            # Update one service at a time
            docker compose -f docker-compose.prod.yml up -d --no-deps api
            sleep 30
            curl -f http://localhost:8000/api/v1/health || exit 1

            docker compose -f docker-compose.prod.yml up -d --no-deps frontend
            sleep 10

            docker compose -f docker-compose.prod.yml up -d --no-deps scanner
            sleep 10

            echo "Deployment complete: ${{ needs.build.outputs.version }}"

      - name: Verify Production Deployment
        run: |
          # Wait for deployment to propagate
          sleep 30

          # Test production health endpoint
          curl -sf https://api.barrierefrei-check.de/api/v1/health || {
            echo "Production health check failed!"
            exit 1
          }

          echo "Production deployment verified: ${{ needs.build.outputs.version }}"

      - name: Notify deployment
        if: success()
        run: |
          echo "Production deployment successful: ${{ needs.build.outputs.version }}"

  # Rollback job (can be triggered manually)
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && inputs.environment == 'production'
    needs: deploy-production

    steps:
      - name: Rollback to previous version
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          script: |
            cd /opt/accessibilitychecker

            # Read previous color
            CURRENT_COLOR=$(cat .current-color)
            if [ "$CURRENT_COLOR" = "blue" ]; then
              ROLLBACK_COLOR="green"
            else
              ROLLBACK_COLOR="blue"
            fi

            echo "Rolling back from $CURRENT_COLOR to $ROLLBACK_COLOR"

            # Switch traffic back
            if [ -f /etc/nginx/conf.d/accessibilitychecker.conf ]; then
              sed -i "s/800[01]/800${ROLLBACK_COLOR:0:1}/" /etc/nginx/conf.d/accessibilitychecker.conf
              nginx -t && nginx -s reload
            fi

            # Update current color
            echo $ROLLBACK_COLOR > .current-color

            echo "Rollback complete"
